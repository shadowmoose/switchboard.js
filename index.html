<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>switchboard.js</title>
	<meta name="description" content="Documentation for switchboard.js">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">switchboard.js</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>switchboard.js</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#" id="" style="color: inherit; text-decoration: none;">
					<h1><a href="https://shadowmoose.github.io/switchboard.js"><img src="https://i.imgur.com/oK9kwVl.png" alt="switch"></a></h1>
				</a>
				<p><img src="https://github.com/shadowmoose/switchboard.js/workflows/Test%20Package/badge.svg" alt="Tests"> <a href="https://www.npmjs.com/package/switchboard.js"><img src="https://img.shields.io/npm/v/switchboard.js" alt="npm"> <img src="https://img.shields.io/bundlephobia/minzip/switchboard.js?label=bundle%20size" alt="npm bundle size"></a> <img src="https://raw.githubusercontent.com/shadowmoose/switchboard.js/image-data/loc-badge.svg" alt="Lines of Code"> <a href="https://www.jsdelivr.com/package/npm/switchboard.js"><img src="https://data.jsdelivr.com/v1/package/npm/switchboard.js/badge" alt=""></a></p>
				<p>Switchboard.js is a library built to help securely connect users in peer-to-peer networks.
					It&#39;s specifically designed to work even for developers deploying static sites (say, through <a href="https://shadowmoose.github.io/switchboard.js/examples/chat-swarm.html#example">GitHub Pages</a>)
					without an available middleman <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling">signaling</a>
					server to handle peer discovery or authorization.
					With Switchboard it&#39;s possible to deploy anything from a fully in-browser file server, to a media streaming service,
				or even vast online multiplayer applications - all within a single browser tab powered by static HTML.</p>
				<p>With switchboard you can establish traditional <code>client-&gt;host</code> connections, or even connect <em>full swarms of clients</em> together.
					Switchboard handles all the intricacies involved with reconnection and peer discovery, and uses cryptographic peer IDs to securely connect without the risk of impersonators.
				All of this works out of the box in just a few lines of code, and requires zero server setup on the developer&#39;s behalf.</p>
				<a href="#installation" id="installation" style="color: inherit; text-decoration: none;">
					<h2>Installation</h2>
				</a>
				<p>For developers working in a node/typescript environment, <code>npm i switchboard.js</code> or <code>yarn add switchboard.js</code>.</p>
				<p>If you&#39;d prefer a direct bundle for use in a browser script tag, <a href="https://www.jsdelivr.com/package/npm/switchboard.js">grab the latest release link from the jsDelivr global CDN</a>.</p>
				<p>For more help, <a href="https://shadowmoose.github.io/switchboard.js/globals.html">check out the documentation</a>.</p>
				<a href="#enough-talk-give-me-an-example" id="enough-talk-give-me-an-example" style="color: inherit; text-decoration: none;">
					<h2>Enough talk, give me an example</h2>
				</a>
				<p>It&#39;s simple to start with Switchboard. Here&#39;s a sample that connects to a swarm of clients, and sends them each a greeting:</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> Switchboard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;switchboard.js&#x27;</span>;

<span class="hljs-comment">// Create new matchmaker:</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> Switchboard();

<span class="hljs-comment">// Connect to a test swarm of Peers - this can be any ID you&#x27;d like:</span>
c.swarm(<span class="hljs-string">&#x27;test-swarm&#x27;</span>);

<span class="hljs-comment">// Listen for new peer connections as you/they join the swarm:</span>
c.subscribe(<span class="hljs-string">&#x27;peer&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">peer</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Connected to peer:&#x27;</span>, peer.id, peer);
    peer.send(<span class="hljs-string">&#x27;Hello there!&#x27;</span>);
    peer.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Received:&#x27;</span>, data));
})
<span class="hljs-comment">// ...and now you have a fully-connected mesh of Peers!</span></code></pre>
				<p>...or perhaps you&#39;d like to implement a client-&gt;host connection, using persistent IDs that survive through browser restarts?</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> Switchboard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;switchboard.js&#x27;</span>;

<span class="hljs-comment">// Load a secret code from storage, or one will auto-generate if one isn&#x27;t already saved:</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> Switchboard({<span class="hljs-attr">seed</span>: <span class="hljs-built_in">localStorage</span>[<span class="hljs-string">&#x27;secretSeed&#x27;</span>]});

<span class="hljs-comment">// Connect to the host:</span>
c.findHost(<span class="hljs-string">&#x27;Host-ID&#x27;</span>);

<span class="hljs-comment">// If we were the host instead:</span>
<span class="hljs-comment">// c.host();</span>

<span class="hljs-comment">// Listen for the Host - they can be online already, or pop online in the future:</span>
c.subscribe(<span class="hljs-string">&#x27;peer&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">peer</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Connected to the Host:&#x27;</span>, peer.id, peer);
    peer.send(<span class="hljs-string">&#x27;Hello there, Mr. Host!&#x27;</span>);
    peer.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Received from host:&#x27;</span>, data));
})

<span class="hljs-built_in">localStorage</span>[<span class="hljs-string">&#x27;secretSeed&#x27;</span>] = c.secretSeed; <span class="hljs-comment">// Store this identity for use later on reload.</span>
<span class="hljs-comment">// The browser will now reuse the same identity whenever it reloads!</span></code></pre>
				<p>You can see the code is pretty much the same either way, thanks to the simple API.
					For more examples, see <a href="https://shadowmoose.github.io/switchboard.js/examples/index.html">the examples directory, deployed to github-pages</a>.
					There are also many more advanced ways to customize the behavior of Switchboard, including hooking events and authorization,
				and you can <a href="https://shadowmoose.github.io/switchboard.js/globals.html">read more about those here</a></p>
				<a href="#okay-so-how39s-it-work" id="okay-so-how39s-it-work" style="color: inherit; text-decoration: none;">
					<h2>Okay, so how&#39;s it work?</h2>
				</a>
				<p>Switchboard is lightweight, small, simple, and extremely fast.
					This was accomplished by writing the WebRTC code completely from scratch, instead of relying on existing libraries.
				Skipping the usual bloated WebRTC libraries in favor of direct API access has several major advantages:</p>
				<ul>
					<li><strong>Fewer Dependencies:</strong> Because it sits right on top of the built-in browser WebRTC API, we can avoid the giant dependency stacks the more common libraries come with.</li>
					<li><strong>Bundling and Types:</strong> Rewriting the common stuff in TypeScript gets us full tree-shaking for a minimal bundle size, easy reference for the API, and <a href="https://shadowmoose.github.io/switchboard.js/globals.html">great documentation.</a></li>
					<li><strong>Faster:</strong> Switchboard manages its own connections and authentication, so it can establish and validate incoming connections much faster - typically before the connection is even fully established!</li>
				</ul>
				<a href="#so-there-aren39t-any-servers-involved" id="so-there-aren39t-any-servers-involved" style="color: inherit; text-decoration: none;">
					<h2>So there aren&#39;t any servers involved?</h2>
				</a>
				<p>Well... no. Unfortunately, that&#39;s impossible in the current world of WebRTC. However - there are so many public resources available these days, that a developer need not roll their own matchmaking server!</p>
				<p>Switchboard makes use of decentralized, public, battle-tested peering systems that exist online. Rather than relying on a single always-on server that the developer would have to set up, maintain, and secure - Switchboard piggybacks off the existing tracker infrastructure used web-wide by systems like WebTorrent. Switchboard will automatically connect to every tracker it is told about, to be sure it has multiple redundant fallbacks. </p>
				<p>Having multiple public trackers at its disposal makes Switchboard far more reliable than most services can hope to achieve. You can simply use the default, list of public trackers, or provide your own. Built-in custom logic deals with these servers for you, and Switchboard won&#39;t fail unless none of the provided servers can be reached. Is one tracker offline or unreachable in a region? No problem - Switchboard will handle the disconnection, retries, and finding Peers via the other available trackers, all without user intervention.</p>
				<p>If you have the resources and don&#39;t want to use public servers, it is trivial to spin up <a href="https://github.com/webtorrent/bittorrent-tracker">your own private server</a>. However, you don&#39;t need to worry about security when using public servers either. Switchboard uses public key encryption on top of a simple cryptographic ID fingerprint system for every single connection. Wherever you are, whatever you use, whenever you connect to somebody, you will always know they&#39;re exactly who they say they are.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class">
						<a href="classes/connectedpeer.html" class="tsd-kind-icon">Connected<wbr>Peer</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/peer.html" class="tsd-kind-icon">Peer</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/switchboard.html" class="tsd-kind-icon">Switchboard</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/peerconfig.html" class="tsd-kind-icon">Peer<wbr>Config</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/sbclientoptions.html" class="tsd-kind-icon">SBClient<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/trackeroptions.html" class="tsd-kind-icon">Tracker<wbr>Options</a>
					</li>
					<li class=" tsd-kind-variable">
						<a href="globals.html#default_trackers" class="tsd-kind-icon">DEFAULT_<wbr>TRACKERS</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#enablelogging" class="tsd-kind-icon">enable<wbr>Logging</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
</body>
</html>